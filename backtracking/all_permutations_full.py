"""
В этой задаче мы хотим определить все возможные перестановки
заданной последовательности. Мы используем метод backtracking (возврат)
для решения этой задачи.

Сложность по времени: O(n! * n),
где n обозначает длину заданной последовательности.
(n! - количество перестановок, n - время на копирование каждой перестановки)
"""

from __future__ import annotations  # Для аннотаций типов с обратными ссылками


def generate_all_permutations(sequence: list[int | str]) -> None:
    """
    Основная функция для генерации всех перестановок.
    Инициализирует рекурсивный процесс backtracking.

    Аргументы:
    ----------
    sequence : list[int | str]
        Входная последовательность, для которой генерируются перестановки.
        Может содержать целые числа или строки.

    Возвращает:
    ----------
    None
        Функция печатает перестановки напрямую.

    Примеры:
    --------
    >>> generate_all_permutations([1, 2, 3])
    [1, 2, 3]
    [1, 3, 2]
    [2, 1, 3]
    [2, 3, 1]
    [3, 1, 2]
    [3, 2, 1]

    Алгоритм:
    ---------
    1. Создает список для отслеживания использованных индексов
    2. Вызывает рекурсивную функцию для построения дерева состояний
    """
    # Создаем список для отслеживания использованных элементов
    # [0, 0, 0, ...] где 0 означает "не использован", 1 - "использован"
    # Длина списка равна длине sequence
    index_used = [0 for i in range(len(sequence))]

    # Начинаем рекурсивное построение дерева состояний
    # Параметры:
    # - sequence: исходная последовательность
    # - []: пустой список для текущей перестановки
    # - 0: начинаем с индекса 0
    # - index_used: список для отслеживания использованных элементов
    create_state_space_tree(sequence, [], 0, index_used)


def create_state_space_tree(
        sequence: list[int | str],
        current_sequence: list[int | str],
        index: int,
        index_used: list[int],
) -> None:
    """
    Создает дерево пространства состояний для итерации по каждой ветви с помощью DFS (поиска в глубину).
    Мы знаем, что каждое состояние имеет ровно len(sequence) - index потомков.
    Завершается, когда достигает конца заданной последовательности.

    Аргументы:
    ----------
    sequence : list[int | str]
        Исходная последовательность, для которой генерируются перестановки.

    current_sequence : list[int | str]
        Текущая перестановка, которая строится.

    index : int
        Текущая позиция в перестановке, которую мы заполняем.

    index_used : list[int]
        Список для отслеживания, какие элементы уже использованы в текущей перестановке.
        0 - элемент не использован, 1 - элемент использован.

    Возвращает:
    ----------
    None
        Функция печатает завершенные перестановки.

    Примеры:
    --------
    Пример 1:
    >>> sequence = [1, 2, 3]
    >>> current_sequence = []
    >>> index_used = [0, 0, 0]  # Эквивалентно [False, False, False]
    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)
    [1, 2, 3]
    [1, 3, 2]
    [2, 1, 3]
    [2, 3, 1]
    [3, 1, 2]
    [3, 2, 1]

    Пример 2:
    >>> sequence = ["A", "B", "C"]
    >>> current_sequence = []
    >>> index_used = [0, 0, 0]
    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)
    ['A', 'B', 'C']
    ['A', 'C', 'B']
    ['B', 'A', 'C']
    ['B', 'C', 'A']
    ['C', 'A', 'B']
    ['C', 'B', 'A']

    Пример 3:
    >>> sequence = [1]
    >>> current_sequence = []
    >>> index_used = [0]
    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)
    [1]

    Дерево рекурсии для sequence = [1, 2, 3]:
    ---------------------------------------------------
    Уровень 0: начинаем с пустого списка []

    Уровень 1: первый элемент может быть 1, 2 или 3
    - Выбираем 1: [1], использованы: [1, 0, 0]
    - Выбираем 2: [2], использованы: [0, 1, 0]
    - Выбираем 3: [3], использованы: [0, 0, 1]

    Уровень 2: для каждой ветви выбираем второй элемент
    Например, для ветви [1]:
    - Остались 2 и 3 (использованы [1, 0, 0])
    - [1, 2], использованы: [1, 1, 0]
    - [1, 3], использованы: [1, 0, 1]

    Уровень 3: выбираем последний элемент
    Например, для ветви [1, 2]:
    - Остался только 3
    - [1, 2, 3], использованы: [1, 1, 1] -> ПЕЧАТАЕМ!

    Затем backtracking: возвращаемся и пробуем другие варианты.
    """

    # БАЗОВЫЙ СЛУЧАЙ рекурсии: мы построили полную перестановку
    if index == len(sequence):
        # Длина current_sequence равна длине sequence
        # Это означает, что мы использовали все элементы
        print(current_sequence)
        return

    # РЕКУРСИВНЫЙ СЛУЧАЙ: нужно добавить следующий элемент
    # Перебираем ВСЕ элементы последовательности
    for i in range(len(sequence)):
        # Проверяем, не использован ли уже этот элемент в текущей перестановке
        if not index_used[i]:
            # Шаг 1: ДОБАВЛЯЕМ элемент в текущую перестановку
            current_sequence.append(sequence[i])

            # Шаг 2: ОТМЕЧАЕМ элемент как использованный
            # Это предотвращает повторное использование того же элемента
            index_used[i] = 1  # или True

            # Шаг 3: РЕКУРСИВНЫЙ ВЫЗОВ для следующей позиции
            # index + 1: переходим к заполнению следующей позиции в перестановке
            create_state_space_tree(sequence, current_sequence, index + 1, index_used)

            # Шаг 4: BACKTRACKING - ВОЗВРАЩАЕМСЯ НАЗАД
            # Удаляем последний элемент, чтобы попробовать другой вариант
            current_sequence.pop()

            # Шаг 5: СНИМАЕМ отметку об использовании
            # Теперь этот элемент снова доступен для других ветвей
            index_used[i] = 0  # или False


"""
Убрать комментарий, чтобы принимать ввод от пользователя

print("Введите элементы")
sequence = list(map(int, input().split()))
"""

# Демонстрация работы алгоритма
if __name__ == "__main__":
    print("Пример 1: Числовая последовательность")
    print("=" * 40)
    sequence: list[int | str] = [3, 1, 2, 4]
    print(f"Исходная последовательность: {sequence}")
    print(f"Ожидаемое количество перестановок: 4! = {4 * 3 * 2 * 1}")
    print("Все перестановки:")
    generate_all_permutations(sequence)

    print("\n" + "=" * 40 + "\n")

    print("Пример 2: Строковая последовательность")
    print("=" * 40)
    sequence_2: list[int | str] = ["A", "B", "C"]
    print(f"Исходная последовательность: {sequence_2}")
    print(f"Ожидаемое количество перестановок: 3! = {3 * 2 * 1}")
    print("Все перестановки:")
    generate_all_permutations(sequence_2)