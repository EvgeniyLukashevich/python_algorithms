"""
В этой задаче мы хотим определить все возможные подпоследовательности
заданной последовательности. Мы используем метод backtracking (возврат)
для решения этой задачи.

Сложность по времени: O(2^n),
где n обозначает длину заданной последовательности.
2^n - это количество всех подмножеств (степенное множество).
"""

from __future__ import annotations  # Для аннотаций типов с обратными ссылками

from typing import Any  # Для работы с любыми типами данных


def generate_all_subsequences(sequence: list[Any]) -> None:
    """
    Основная функция для генерации всех подпоследовательностей.
    Инициализирует рекурсивный процесс backtracking.

    Аргументы:
    ----------
    sequence : list[Any]
        Входная последовательность, для которой генерируются подпоследовательности.
        Может содержать элементы любого типа.

    Возвращает:
    ----------
    None
        Функция печатает подпоследовательности напрямую.

    Пример:
    -------
    >>> generate_all_subsequences([3, 2, 1])
    []
    [1]
    [2]
    [2, 1]
    [3]
    [3, 1]
    [3, 2]
    [3, 2, 1]

    Алгоритм:
    ---------
    1. Начинаем с пустой подпоследовательности
    2. Рекурсивно строим бинарное дерево решений
    """
    # Начинаем рекурсивное построение дерева состояний
    # Параметры:
    # - sequence: исходная последовательность
    # - []: пустая текущая подпоследовательность
    # - 0: начинаем с индекса 0
    create_state_space_tree(sequence, [], 0)


def create_state_space_tree(
        sequence: list[Any],
        current_subsequence: list[Any],
        index: int
) -> None:
    """
    Создает дерево пространства состояний для итерации по каждой ветви с помощью DFS.
    Мы знаем, что каждое состояние имеет ровно два потомка.
    Завершается, когда достигает конца заданной последовательности.

    Аргументы:
    ----------
    sequence : list[Any]
        Исходная последовательность.

    current_subsequence : list[Any]
        Текущая подпоследовательность, которая строится.

    index : int
        Текущий индекс в исходной последовательности, который мы рассматриваем.

    Возвращает:
    ----------
    None
        Функция печатает завершенные подпоследовательности.

    Примеры:
    --------
    Пример 1:
    >>> sequence = [3, 2, 1]
    >>> current_subsequence = []
    >>> create_state_space_tree(sequence, current_subsequence, 0)
    []
    [1]
    [2]
    [2, 1]
    [3]
    [3, 1]
    [3, 2]
    [3, 2, 1]

    Пример 2:
    >>> sequence = ["A", "B"]
    >>> current_subsequence = []
    >>> create_state_space_tree(sequence, current_subsequence, 0)
    []
    ['B']
    ['A']
    ['A', 'B']

    Пример 3:
    >>> sequence = []
    >>> current_subsequence = []
    >>> create_state_space_tree(sequence, current_subsequence, 0)
    []

    Пример 4:
    >>> sequence = [1, 2, 3, 4]
    >>> current_subsequence = []
    >>> create_state_space_tree(sequence, current_subsequence, 0)
    []
    [4]
    [3]
    [3, 4]
    [2]
    [2, 4]
    [2, 3]
    [2, 3, 4]
    [1]
    [1, 4]
    [1, 3]
    [1, 3, 4]
    [1, 2]
    [1, 2, 4]
    [1, 2, 3]
    [1, 2, 3, 4]

    Дерево рекурсии для sequence = [1, 2, 3]:
    ---------------------------------------------------
    Уровень 0 (index=0, элемент=1)
    ├─ Ветка 1: НЕ включаем элемент 1
    │  Уровень 1 (index=1, элемент=2)
    │  ├─ Ветка 1.1: НЕ включаем элемент 2
    │  │  Уровень 2 (index=2, элемент=3)
    │  │  ├─ Ветка 1.1.1: НЕ включаем элемент 3 -> [] ✓
    │  │  └─ Ветка 1.1.2: включаем элемент 3 -> [3] ✓
    │  └─ Ветка 1.2: включаем элемент 2
    │     Уровень 2 (index=2, элемент=3)
    │     ├─ Ветка 1.2.1: НЕ включаем элемент 3 -> [2] ✓
    │     └─ Ветка 1.2.2: включаем элемент 3 -> [2, 3] ✓
    └─ Ветка 2: включаем элемент 1
       Уровень 1 (index=1, элемент=2)
       ├─ Ветка 2.1: НЕ включаем элемент 2
       │  Уровень 2 (index=2, элемент=3)
       │  ├─ Ветка 2.1.1: НЕ включаем элемент 3 -> [1] ✓
       │  └─ Ветка 2.1.2: включаем элемент 3 -> [1, 3] ✓
       └─ Ветка 2.2: включаем элемент 2
          Уровень 2 (index=2, элемент=3)
          ├─ Ветка 2.2.1: НЕ включаем элемент 3 -> [1, 2] ✓
          └─ Ветка 2.2.2: включаем элемент 3 -> [1, 2, 3] ✓

    Всего: 2³ = 8 подпоследовательностей
    """

    # БАЗОВЫЙ СЛУЧАЙ рекурсии: мы достигли конца последовательности
    if index == len(sequence):
        # Выводим текущую подпоследовательность
        print(current_subsequence)
        return

    # РЕКУРСИВНЫЙ СЛУЧАЙ: у нас есть два варианта для текущего элемента

    # ВАРИАНТ 1: НЕ включать текущий элемент в подпоследовательность
    # Просто переходим к следующему элементу
    create_state_space_tree(sequence, current_subsequence, index + 1)

    # ВАРИАНТ 2: ВКЛЮЧИТЬ текущий элемент в подпоследовательность
    # Шаг 1: Добавляем текущий элемент
    current_subsequence.append(sequence[index])

    # Шаг 2: Рекурсивно обрабатываем оставшиеся элементы
    create_state_space_tree(sequence, current_subsequence, index + 1)

    # Шаг 3: Backtracking - удаляем элемент, чтобы вернуться к предыдущему состоянию
    # Это нужно для исследования других ветвей дерева
    current_subsequence.pop()


if __name__ == "__main__":
    print("Пример 1: Числовая последовательность")
    print("=" * 40)
    seq: list[Any] = [1, 2, 3]
    print(f"Исходная последовательность: {seq}")
    print(f"Ожидаемое количество подпоследовательностей: 2^{len(seq)} = {2 ** len(seq)}")
    print("Все подпоследовательности (в обратном порядке из-за реализации):")
    generate_all_subsequences(seq)

    print("\n" + "=" * 40 + "\n")

    print("Пример 2: Строковая последовательность")
    print("=" * 40)
    seq.clear()  # Очищаем список
    seq.extend(["A", "B", "C"])  # Добавляем новые элементы
    print(f"Исходная последовательность: {seq}")
    print(f"Ожидаемое количество подпоследовательностей: 2^{len(seq)} = {2 ** len(seq)}")
    print("Все подпоследовательности:")
    generate_all_subsequences(seq)