# Классическая комбинаторная задача.
# Алгоритм всех возможных комбинаций.
# Одна комбинация состоит из k элементов, n - всего элементов.
# Элементы и комбинации не повторяются.

# Основные применения:
# * Комбинаторика и теория вероятностей - подсчет количества вариантов
# * Алгоритмы и структуры данных - рекурсивные решения задач
# * Обработка данных - выбор подмножеств данных для анализа
# * Тестирование - генерация тестовых наборов параметров
# * Игровые алгоритмы - расчет возможных ходов, комбинаций карт
# * Машинное обучение - выбор признаков (feature selection)
# * Оптимизация - перебор вариантов в задачах выбора

# Требования для работы
# Python 3.x
# Модуль itertools (для comparison_lists)

# Входные параметры:
# n - общее количество элементов (положительное целое число)
# k - количество выбираемых элементов (неотрицательное целое число)


"""
В этой задаче мы хотим определить все возможные комбинации k чисел из диапазона 1 ... n.
Мы используем метод backtracking (возврат) для решения этой задачи.

Сложность по времени: O(C(n,k)), что равно O(число сочетаний из n по k) = O((n!/(k! * (n - k)!))),
где C(n,k) - биномиальный коэффициент.
"""

from __future__ import annotations  # Для аннотаций типов, которые ссылаются на классы в том же модуле

from itertools import combinations  # Импортируем встроенную функцию для генерации комбинаций


def combination_lists(n: int, k: int) -> list[list[int]]:
    """
    Генерирует все возможные комбинации k чисел из диапазона 1 ... n с использованием itertools.

    Эта функция использует встроенный модуль itertools для сравнения с нашей реализацией на основе backtracking.

    Аргументы:
    ----------
    n : int
        Максимальное число в диапазоне (от 1 до n включительно)
    k : int
        Количество чисел в каждой комбинации

    Возвращает:
    ----------
    list[list[int]]
        Список всех комбинаций, где каждая комбинация представлена списком чисел

    Примеры:
    --------
    >>> combination_lists(n=4, k=2)
    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]

    Примечания:
    ----------
    - combinations(range(1, n+1), k) создает итератор кортежей
    - list(x) преобразует каждый кортеж в список
    - [list(x) for x in ...] создает список списков
    """
    return [list(x) for x in combinations(range(1, n + 1), k)]


def generate_all_combinations(n: int, k: int) -> list[list[int]]:
    """
    Генерирует все возможные комбинации k чисел из диапазона 1 ... n с использованием backtracking.

    Аргументы:
    ----------
    n : int
        Максимальное число в диапазоне (от 1 до n включительно)
    k : int
        Количество чисел в каждой комбинации

    Возвращает:
    ----------
    list[list[int]]
        Список всех комбинаций, где каждая комбинация представлена списком чисел

    Исключения:
    ----------
    ValueError
        Если k отрицательное или n отрицательное

    Примеры:
    --------
    >>> generate_all_combinations(n=4, k=2)
    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]

    >>> generate_all_combinations(n=0, k=0)
    [[]]

    >>> generate_all_combinations(n=10, k=-1)
    Traceback (most recent call last):
        ...
    ValueError: k must not be negative

    >>> generate_all_combinations(n=-1, k=10)
    Traceback (most recent call last):
        ...
    ValueError: n must not be negative

    >>> generate_all_combinations(n=5, k=4)
    [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]

    >>> generate_all_combinations(n=3, k=3)
    [[1, 2, 3]]

    >>> generate_all_combinations(n=3, k=1)
    [[1], [2], [3]]

    >>> generate_all_combinations(n=1, k=0)
    [[]]

    >>> generate_all_combinations(n=1, k=1)
    [[1]]

    Алгоритм:
    ---------
    Используется метод backtracking (возврата):
    1. Начинаем с пустого списка
    2. Рекурсивно добавляем элементы
    3. Когда достигаем нужной длины k, сохраняем комбинацию
    4. Возвращаемся назад (удаляем последний элемент) и пробуем другие варианты
    """
    # Проверяем входные данные
    if k < 0:
        raise ValueError("k must not be negative")
    if n < 0:
        raise ValueError("n must not be negative")

    # Создаем список для хранения всех комбинаций
    result: list[list[int]] = []

    # Вызываем вспомогательную рекурсивную функцию
    # Параметры:
    # - increment=1: начинаем с числа 1
    # - total_number=n: всего чисел n
    # - level=k: нужно выбрать k чисел
    # - current_list=[]: начальный пустой список
    # - total_list=result: ссылка на список для результатов
    create_all_state(1, n, k, [], result)

    # Возвращаем все найденные комбинации
    return result


def create_all_state(
        increment: int,
        total_number: int,
        level: int,
        current_list: list[int],
        total_list: list[list[int]],
) -> None:
    """
    Вспомогательная функция для рекурсивного построения всех комбинаций.

    Аргументы:
    ----------
    increment : int
        Минимальное число, с которого начинается следующий выбор
        Гарантирует, что комбинации будут в возрастающем порядке и без повторений

    total_number : int
        Общее количество чисел (n)

    level : int
        Сколько чисел осталось добавить к текущей комбинации

    current_list : list[int]
        Текущая частичная комбинация

    total_list : list[list[int]]
        Список для сохранения завершенных комбинаций

    Возвращает:
    ----------
    None
        Функция изменяет total_list напрямую

    Примеры:
    --------
    >>> create_all_state(1, 4, 2, [], result := [])
    >>> result
    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]

    >>> create_all_state(1, 3, 3, [], result := [])
    >>> result
    [[1, 2, 3]]

    >>> create_all_state(2, 2, 1, [1], result := [])
    >>> result
    [[1, 2]]

    >>> create_all_state(1, 0, 0, [], result := [])
    >>> result
    [[]]

    >>> create_all_state(1, 4, 0, [1, 2], result := [])
    >>> result
    [[1, 2]]

    >>> create_all_state(5, 4, 2, [1, 2], result := [])
    >>> result
    []

    Работа алгоритма:
    -----------------
    1. Базовый случай: если level == 0, сохраняем текущую комбинацию
    2. Иначе: для каждого i от increment до total_number - level + 2:
       a. Добавляем i в текущую комбинацию
       b. Рекурсивно вызываем функцию с обновленными параметрами:
          - increment = i + 1 (чтобы избежать повторений)
          - level = level - 1 (уменьшаем количество оставшихся элементов)
       c. Удаляем i из текущей комбинации (backtracking)

    Объяснение границ цикла:
    -----------------------
    total_number - level + 2 - это верхняя граница для i

    Почему именно так?
    - Нам нужно выбрать level элементов
    - Если мы выбрали элемент i, то останется выбрать level-1 элементов
    - Максимальный i, который мы можем выбрать, должен оставить достаточно
      элементов для выбора оставшихся level-1 элементов
    - Последний возможный i: total_number - (level - 1) = total_number - level + 1
    - В Python range верхняя граница не включается, поэтому +2

    Пример: n=4, k=2 (level=2)
    - increment начинается с 1
    - Верхняя граница: 4 - 2 + 2 = 4
    - range(1, 4) дает i = 1, 2, 3
    - Для i=1: останется выбрать 1 элемент из {2,3,4}
    - Для i=2: останется выбрать 1 элемент из {3,4}
    - Для i=3: останется выбрать 1 элемент из {4}
    """
    # Базовый случай рекурсии: мы выбрали все k элементов
    if level == 0:
        # Добавляем копию текущего списка в результат
        # Используем срез [:] или copy() для создания копии,
        # иначе все элементы total_list будут ссылаться на один и тот же список
        total_list.append(current_list[:])
        return

    # Рекурсивный случай: нужно выбрать еще level элементов
    # Перебираем все возможные числа, которые можно добавить
    # Верхняя граница: total_number - level + 2
    # Объяснение: см. выше в комментариях
    for i in range(increment, total_number - level + 2):
        # 1. Добавляем текущее число в комбинацию
        current_list.append(i)

        # 2. Рекурсивно вызываем функцию для следующего уровня
        #    - increment = i + 1: следующий элемент должен быть больше текущего
        #      Это гарантирует возрастающий порядок и отсутствие повторений
        #    - level - 1: уменьшаем количество оставшихся элементов
        create_all_state(i + 1, total_number, level - 1, current_list, total_list)

        # 3. Backtracking: удаляем последний элемент, чтобы попробовать другой вариант.
        #    Это позволяет вернуться к предыдущему состоянию и исследовать другие ветви
        current_list.pop()


if __name__ == "__main__":
    # Запускаем doctests для проверки примеров в docstring
    from doctest import testmod

    testmod()

    # Демонстрация работы функции
    print("Пример: n=4, k=2")
    print(generate_all_combinations(n=4, k=2))

    # Проверяем корректность для нескольких значений n и k
    print("\nПроверка корректности (n от 1 до 4, k от 1 до 4):")
    tests = ((n, k) for n in range(1, 5) for k in range(1, 5))
    for n, k in tests:
        is_correct = generate_all_combinations(n, k) == combination_lists(n, k)
        print(f"n={n}, k={k}: {is_correct}")

    # Сравнение производительности двух реализаций
    print("\nСравнение производительности:")
    from timeit import timeit

    for func in ("combination_lists", "generate_all_combinations"):
        # Измеряем время выполнения для n=4, k=2
        execution_time = timeit(f'{func}(n=4, k=2)', globals=globals(), number=10000)
        print(f"{func:>30}(): {execution_time:.6f} секунд (10000 итераций)")